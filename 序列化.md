
# 序列化

## 序列化和反序列化

+ 编写应用程序的时候需要将程序的某些数据存储在内存中，将其写入某个文件或加ing其传输到网络中另一台计算机上实现通讯
+ 过程称为序列化
+ 逆过程成为反序列化

+ [常见几种序列化](https://www.cnblogs.com/malphite/p/10818954.html)

	```txt
		MFC Serialization
		.Net Framework
	```

+ 原因，[概述]( https://blog.csdn.net/GDFHGFHGFH/article/details/120370099)

	```txt
		简单来说序列化就是一种用来处理对象流的机制。所谓对象流也就是将对象的
		内容进行流化，流的概念这里不用多说(就是I/O)。我们可以对流化后的对象进行读写
		操作，也可将流化后的对象传输于网络之间(注：要想将对象传输于网络必须进行流化)！
		在对对象流进行读写操作时会引发一些问题，而序列化机制正是用来解决这些问题的！
		-----------------------------------------------------------------------------------------
		问题的引出：
		如上所述，读写对象会有什么问题呢？比如：我要将对象写入一个磁盘文件而后再将
		其读出来会有什么问题吗？别急，其中一个最大的问题就是对象引用！
		举个例子来说：假如我有两个类，分别是A和B，B类中含有一个指向A类对象的引用，
		现在我们对两个类进行实例化{ A a = new A(); B b = new B(); }。这时在内存中实际上分配
		了两个空间，一个存储对象a，一个存储对象b。接下来我们想将它们写入到磁盘的一个文件
		中去，就在写入文件时出现了问题！因为对象b包含对对象a的引用，所以系统会自动的将a
		的数据复制一份到b中，这样的话当我们从文件中恢复对象时(也就是重新加载到内存中)时，
		内存分配了三个空间，而对象a同时在内存中存在两份，想一想后果吧，如果我想修改对象a
		的数据的话，那不是还要搜索它的每一份拷贝来达到对象数据的一致性，这不是我们所希望的！
		-----------------------------------------------------------------------------------------
		以下序列化机制的解决方案：
		1.保存到磁盘的所有对象都获得一个序列号(1, 2, 3等等)
		2.当要保存一个对象时，先检查该对象是否被保存了
		3.如果以前保存过，只需写入"与已经保存的具有序列号x的对象相同"的标记，否则，保存该对象
		通过以上的步骤序列化机制解决了对象引用的问题！
	```

+ [为什么要实现序列化](https://blog.csdn.net/lhcdate/article/details/111175023)
	+ 场景
		- 当你想把的内存中的对象保存到一个文件中或者数据库中时候；
		- 当你想用套接字在网络上传送对象的时候；
		- 当你想通过RMI传输对象的时候；
	+ 注意事项
		- a)当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；
		- b)当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；
		- c)并非所有的对象都可以序列化，原因：

			```txt
				1.安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行RMI(远程方法调用)传输等，在序列化进行传输的过程中，这个对象的private等域是不受保护的。

				1. 资源分配方面的原因，比如socket，thread类，如果可以序列化	进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现。
			```

		- d)没有实现Serializable接口的父类，编写一个能够序列化的子类
			
			```txt	
				1， 父类要有一个无参的constructor；
				2， 子类要先序列化自身，然后子类要负责序列化父类的域
			```

1. [CArray 用法](http://www.360doc.com/content/13/1223/10/12282510_339435444.shtml)

2. [MFC 控制台测试]( https://www.cnblogs.com/chenshuangjian/p/16672841.html)

## CArchive

```c++
/*显示创建CArchive*/
CArchive archive(&theFile, CArchive::store);
```

1. 为 CArchive 构造函数的第二个参数是指定的枚举值存档是否为存储或加载数据将使用来回文件
2. 对象的 Serialize 功能通过调用 IsStoring 功能检查此状态存档对象
3. 使用完毕之后需要关闭

	```c++
	/*先关闭archive，再关闭文件*/
	archive.Close();
	theFile.Close();
	```

## MFC 文件操作

1. mfc提供了文件操作基类CFile，这个类提供了一个没有缓存的二进制格式的磁盘输入输出功能。通过他的派生类可以间接的支持文本、文件、内存文件等
2. 文件打开

## 整体流程

## 头文件撰写

